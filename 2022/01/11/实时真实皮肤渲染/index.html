<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Meta'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="meta" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.0.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">DrawCall</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="../categories/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/">图形渲染</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/renderring/" title="图形渲染">
		                图形渲染
		            </a>
		        </li>
		        
		        <li>
		            <a href="/deeplearnning/" title="深度学习">
		                深度学习
		            </a>
		        </li>
		        
		        <li>
		            <a href="/imageprocessing/" title="图像处理">
		                图像处理
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="../https:/github.com/eatdreamcat" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="../http:/500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig01.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >实时真实皮肤渲染（GPU Gems3 第十四章）</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>refer to <a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin">https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>得益于现代 GPU 的性能，以及先进的 3D 扫描技术和次表面散射以及皮肤的物理组成研究成果，使得现在实时渲染真实皮肤成为可能。在本章节中，我们将介绍先进的技术去生成这个图片。我们的目标是采用最具有物理真实性的模型以产生更可控的应用。balabala 不看了</p>
<h2 id="14-1-皮肤的表现"><a href="#14-1-皮肤的表现" class="headerlink" title="14.1 皮肤的表现"></a>14.1 皮肤的表现</h2><pre><code>   皮肤一直难以渲染：它有很多微妙的视觉特征，并且人类对皮肤的表现很敏感，特别是脸。人体大量的皮肤细节是一个障碍。
   真实皮肤必须包含：褶皱，毛孔，斑点，毛囊，伤疤等等。幸运的是3D扫描技术允许我们去最大化的捕捉这些细节。
   但是直接的渲染会显得很不真实，难点主要源于次表面散射
   人体皮肤其实是半透明的
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig02.jpg" alt="a" title="a"></p>
<pre><code>   对于大部分材质，光线的反射通常分为两个独立的部分：[1]表面反射，通常以简单的镜面反射来计算；[2]次表面散射，通常用
   简单的漫反射来计算。但是，这两者要求更加精细的模型去生成更真实的皮肤画面。即便精细的贴图，也没办法让皮肤更加真实，
   如果没有精确的高光反射和次表面散射的话。

14.1.1 皮肤的表面反射

    一小部分光（大约6%）射入皮肤表面会直接被反射，不会被着色。因为皮肤最外层（粗糙且油腻）产生的菲涅尔效应，这部分我们可以
    用高光反射函数作为模型。下图演示了这一过程。但这个反射不是完美的反射，因为皮肤会有一定粗糙度，导致当个入射角，会被反射
    成不同的出射角。我们可以用BRDF函数来描述这种因为粗糙度导致的出射角分布。
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig03.jpg" alt="layers of skin" title="layers of skin"></p>
<pre><code>    简单的经验模型比如Blinn-Phong对于皮肤的反射是不够精确的。PBR的计算模型提供了更加精确的效果。后面我们将会了解到如何高效的
    运用这样的模型。

14.1.2 皮肤次表面反射

    任何未在外表面反射的光，都会进入皮肤次表面。皮肤的第二层组织散射和吸收光线，形成颜色和柔和的表现。光进入这层组织，通常会被
    吸收和散射，最终从入射点邻域散射出去。有时光线也会直接穿透，像耳朵的部位。一个真实的皮肤着色模型，必须包含这一散射过程。

    考虑的更加复杂一些，皮肤的不同组织，实际上是以不同的方式吸收和散射光线的。如下图所示
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig04.jpg"></p>
<pre><code>    真实皮肤甚至比这个更加复杂。不过也不必过度的去模拟真实的散射。Donner and Jensen这两个人在2005证实了用单层模型是不可靠的，
    比起用三层模型来说。下面我们会介绍实时渲染中的双层模型。
</code></pre>
<h2 id="14-2-皮肤渲染系统的总览"><a href="#14-2-皮肤渲染系统的总览" class="headerlink" title="14.2 皮肤渲染系统的总览"></a>14.2 皮肤渲染系统的总览</h2><pre><code>这一部分会展示实时皮肤渲染的细节，包含高光反射和次表面散射部分。balabala...
</code></pre>
<h2 id="14-3-高光反射"><a href="#14-3-高光反射" class="headerlink" title="14.3 高光反射"></a>14.3 高光反射</h2><pre><code>Phong虽然广泛应用，但是不准确，这里要用PBR。
Phong体现不出掠射角下的菲涅尔效应，并且没有能量守恒。如下图
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig05.jpg"></p>
<pre><code>14.3.1 把基于物理的高光反射应用到皮肤

    有很多基于物理的BRDFs可以提升皮肤渲染的真实性。这些模型通常都包含比如菲涅尔项，几何衰减项并且有很多参数。

    这些模型通常也会有一个常数项rho_s来控制强度。另外的常用输入是法向，视角向量，光线方向，
    折射率eta（菲涅尔项要用）等，和一个粗糙度。

    计算公式大致如下：
    <pre class="line-numbers language-none"><code class="language-none">specularLight +&#x3D; lightColor[i] * lightShadow[i] * rho_s * specBRDF(N, V, L[i], eta, m) * saturate(dot(N,L[i]));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

    上面公式的参数变量都可以直接计算出来，这里我们不考虑复杂的环境间接光照。

    皮肤的菲涅尔反射

    所有的基于物理的 BRDF 都包含菲涅尔项。这应该是一个非偏振的电介质菲涅尔反射，并且 F0 应该为0.028。这里来袭比尔定律并且
    假设皮肤的折射率为1.4.

    当计算项皮肤这样粗糙的菲涅尔项的时候，所有项应该从半角矢量H去考量，而不是N。Schlick的菲涅尔近似函数在皮肤计算上也表现的
    很好。
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig06.jpg"></p>
<pre><code>    <pre class="line-numbers language-none"><code class="language-none">float fresnelReflectance(float3 H, float3 V, float F0) &#123;
    float base &#x3D; 1.0 - dot(V, H);
    float exponential &#x3D; pow(base, 5.0);
    return exponential + F0 * (1.0 - exponential);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

    分解BRDFS来更有效的计算

    Heidrich and Seidel这两个帅哥描述了一种预计算的阶段有效的提升了BRDF模型的计算效率，即把BRDF分解到各个预计算贴图里。
    我们采用了类似的方法，不过我们只使用单一的预计算贴图（Beckmann 分布函数），并且使用Schlick菲涅尔近似计算高光反射，
    支持变化的roughness。

    我们首先预计算Beckmann分布函数并渲染到一张贴图。（c）展示了这个贴图。这个步骤只需要做一次，当程序启动时或者离线保存好。
    我们使用指数比例并将结果值减半以便于将函数映射到8位的纹理中，然后再镜面反射计算期间，进行一次逆运算去映射真正的值即可。
    （或者，我们也可以使用浮点纹理来减少计算量，但是是以增加纹理带宽为代价的）
    （a）和（b）分别是实时计算的BRDF和预计算的BRDF，两者几乎没有区别
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig07.jpg"><br>以下是预计算 Beckmannn 贴图的代码</p>
<pre><code>    <pre class="line-numbers language-none"><code class="language-none">float PHBeckmann(float ndoth, float m) &#123;
    float alpha &#x3D; acos(ndoth);
    float ta &#x3D; tan(alpha);
    float val &#x3D; 1.0 &#x2F; (m*m*pow(ndot, 4.0))*exp(-(ta*ta)&#x2F;(m*m));
    return val;
&#125;
&#x2F;&#x2F; 渲染到512x512的贴图
float KStextureCompute(float2 tex:TEXCOODR0) &#123;
    &#x2F;&#x2F; Scale the value to fit within [0,1] – invert upon lookup.
    return 0.5 * pow( PHBeckmann( tex.x, tex.y ), 0.1 );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
    我的计算结果如下：
</code></pre>
<p><img src="https://wx2.sinaimg.cn/mw2000/006TbTv5gy1gya8gashk5j30ei0fvjsa.jpg"></p>
<pre><code>    皮肤的高光反射是白色的

    因为细胞和油脂都是电介质，所以高光反射是不带颜色的，如果是金属的话，就会带有金属色。
    这里需要注意的是，如果没有做gamma和linear的转换，在计算漫反射添加高光时，会泛黄。

    改变皮肤的高光参数

    有一个关于人脸的研究，基于有Beckmann微平面法线分布函数的BRDF模型测量参数，他们测量了149
    个面的10中不同面部粗糙度m和高光系数rho_s。结果发表在SIGGRAPH 2006上，对调整镜面反射参数
    提供了一个很好的开始。

    Torrance/Sparrow模型和Kelemen/Szirmay-Kalos很接近并且对测量数据也表现的很好。他们的数据
    可以更容易的被绘制进低分辨率2通道的图中，分别用这两通道代表roughness和rho_s.

    下面两张图对比了渲染和测量数据，整体差异不大，但是细节提升很多啊。
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig08.jpg"></p>
<h2 id="14-4-漫反射理论"><a href="#14-4-漫反射理论" class="headerlink" title="14.4 漫反射理论"></a>14.4 漫反射理论</h2><pre><code>    现在我们来讨论漫反射，在开始之前，我们得先了解一下Diffuse Profile。
    这个关键的概念时来自次表面散射理论，来自于数学和物理结合的，对于一个光线在半透明物体中传播和散射
    的研究。

    这里我们不考虑单次散射，在皮肤渲染中这是可以接受的，但是对于某些材料例如大理石，玉石，烟雾等，单词散射
    则会很明显的影响外观。在渲染这些物体时，必须把单次散射考虑在内。

    14.4.1 Diffuse Profile

    Diffuse Profile对半透明物体内部的散射有一个很好的近似。这个测量是，在一个黑暗房间中的平坦表面，用一束
    很细的白色激光照射它。会在表面中心点看到光在内部传播现象。前提是这个平面足够大且表面平坦。
    结果如下图
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig09.jpg"></p>
<pre><code>    可以发现一个特别之处，我们用的是白色光，但是这里内部显示出来的光却带有颜色且偏红，这是因为红色相比蓝色和绿色，
    有更好的散射。皮肤的吸收特性，对频率变化特别敏感。事实上，研究人员已经做过150个色带中的散射模型，得到150个
    Diffuse Profile。当然，我们这里直接使用RGB的就可以啦。

    14.4.2 基于Diffuse Profiles的渲染

    在给定Diffuse Profile的基础下，模拟次表面散射，可以减少很多计算邻域光照贡献的过程。每一点的光照计算，都应该
    考虑的别邻域对这个点的光照贡献。点和点之间的都会互相影响。

    漫反射中因为光线传播很快，因此我们可以直接叠加这些光线而不考虑方向。（除了N·L项和菲涅尔）

    对于次表面散射，有Diffuse Profile决定，并假定它从表面的四面八方散射出去。（对于菲涅尔效应，为了真实性，在
    漫反射离开的表面也应该考虑）

    散射模型在不同材质属性下广泛使用。在这些属性中，使用偶极子方程计算轮廓。后来，又有论文介绍了处理多层材料的
    多极理论。他们也提出了三层皮肤模型，我们将这个理论应用到皮肤渲染中。

    和偶极子理论一起，那个男人也提出了一个高效的使用Diffuse Profile渲染曲面的技术。这个想法是简单的使用表面
    上的两点直接的距离来评估扩散剖面。如下图
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig10.jpg"></p>
<pre><code>    14.4.3 扩散剖面的形状

    准确的渲染要求我们要知道一个材质扩散剖面的确切形状。简单的偶极子模型可以满足很多材质。要渲染牛奶，大理石等，
    我们可以查找测量的散射系数并使用偶极子模型来计算扩散剖面。

    但是，对于多层材质的模型，偶极子显然不够用了。
    使用更复杂的多极子模型可以显著改善皮肤这种多层材料的视觉效果。
    下图是单层材料模型和多层的一个渲染效果对比
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig11.jpg"></p>
<pre><code>    偶极子模型下，皮肤看起来偏蜡质效果。

    14.4.4 多次高斯拟合扩散剖面

    单个高斯没办法准确的拟合扩散剖面的曲线图，但是多次高斯的叠加，可以很好的拟合扩散剖面的曲线。高斯的独特之处在于
    它是可分离和径向对称的，可以通过互相卷积产生新的高斯。
    下面这个公式，需要一个偶极子或者多极子去映射高斯和。对于每一个扩散剖面R(r),我们用k个高斯找到方差vi和权重wi，如下
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/309equ01.jpg"></p>
<pre><code>    以下是关于v的高斯公式
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/309equ02.jpg"></p>
<pre><code>    下图展示了用两个和四个高斯和拟合的曲线。参数使用来自 Jensen et al.2001
</code></pre>
<p><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig12.jpg"></p>
<pre><code>    四个高斯和采用：
</code></pre>
<p>$R(r) = 0.070G(0.036, r) + 0.18G(0.14, r) + 0.21G(0.91, r) + 0.29G(7.0, r)$</p>
<pre><code>    14.4.5 拟合预测或测量剖面
</code></pre>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://eatdreamcat.github.io/2022/01/11/%E5%AE%9E%E6%97%B6%E7%9C%9F%E5%AE%9E%E7%9A%AE%E8%82%A4%E6%B8%B2%E6%9F%93/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://eatdreamcat.github.io/2022/01/11/%E5%AE%9E%E6%97%B6%E7%9C%9F%E5%AE%9E%E7%9A%AE%E8%82%A4%E6%B8%B2%E6%9F%93/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
